

    [计算机网络]
    “自定制协议”
     客户端给服务器发送的消息是啥格式
     服务器返回给客户端的消息又是啥格式
        请求(request)和响应(response)中包含的信息有哪些
        请求数据和响应数据如何组织（具体按照啥格式来序列化）
            序列化：把对象变为字符串
            反序列化：把字符串变为对象
            序列化的常见方式：
                 xml:
                 json:
                    优点：方便调试
                    缺点：传输效率低

    HTTP协议：
           打开一个网页都是靠HTTP协议
           HTTPS是基于HTTP来实现的，多了一个加密层
           url:网址/链接
               ip地址不太记忆和传播，用一些更好记忆的字符串来表示---域名，浏览器在访问域名的时候会自动把域名转成ip地址
               路径表示主机上的具体的资源（文件或者虚拟的文件）
               查询字符串（query--string）中的键值对都是用户自定义协议的一部分
               urlencode:query--string中如果包含了特定字符，都需要进行转义 %[十六进制数字]
      HTTP请求：
              1.首行
                 a）方法 GET/POST/PUT/DELECT
                        常用的方法：GET/POST/PUT/DELECT/HEAD...
                        GET与POST的区别：
                           GET请求往往把自定制数据放在quary_string中
                           POST请求往往把自定制数据放在body中
                 b）url 
                 c）版本号 HTTP/1.1   HTTP/2.0    HTTP/3.0 
                 三部分之间用空格隔开
             2.协议头（header)
                常见的header：
                      Content-Type:描述了body的数据格式类型
                      Content-Length：描述了body的数据长度
                      Host：描述了访问的主机名（域名/ip）
                      Referer：当前页面是从哪个页面跳转过来的
                      Cookie：字符串，浏览器本地存储的能力之一
                                     中经常会包含一种叫做“身份识别”的信息
                                     session id 
                      session   服务器端维护的一个数据结构，记录了用户的身份信息，session id 就是session对象的唯一身份标识，session id保存在浏览器中，浏览器后续再访问服务器的时候，就会自动带着session id ，从而让服务器知道当前请求是哪个用户发来的
                     服务器端使用一个hash table 之类的结构来维护若干个用户身份信息，key就是session id，value就是完整的session对象
                 Cookie是按照Host这个header来划分的
                 User Agent
                 若干个键值对
                 每个键值对占一行，每个键与值之间使用：分割
             3. 空行
                 表示header到这里就结束了

             4.协议正文（body）
                   一般GET请求没有body，POST有
    HTTP响应：
            1.首行
                a）版本号
                b）状态码
                        200 OK 表示访问成功（2XX  表示访问成功）
                        302  Found  表示重定向（3XX 表示重定向）
                        404  Not Found 没有找到指定资源（4XX 表示客户端出错）
                        403 Forbidden 没有权限
                        418 彩蛋哈哈哈
                        502 Bad Gateway 服务器挂了（5XX  表示服务器出错）
                        504 Gateway Timeout  服务器响应超时                   
                c）状态码描述信息
            2.协议头（header）
                仍然是键值对
                每个键值对占一行，每个键与值之间使用：分割
            3.空行
                header部分结束标记
            4.协议正文（body）
                响应中的正文格式也有很多种
                可以使一个html，也可以是cs...

    传输层：
    传输层负责端到端之间的传输：只关注起点到终点
    源ip/源端口
    目的ip/目的端口
    ip地址：是一个32位的整数，IP协议中来描述的（网络层）
    端口号，区分一台主机上的哪个程序，是一个16位的整数（0-65535）（传输层）

    UDP上限64KB
    UDP校验和：使用CRC校验，取每个字节，把每个字节依次循环相加，得到一个最终的数字，就是校验和。接收端按照同样的规则再次计算校验和，和发送端的校验和进行对比，如果数据一致，就可以认为数据没有发生错误
    MD5:字符串哈希算法。
    特点：UDP                          TCP
           无连接                       有连接
           不可靠                       可靠传输
           面向数据报                面向字节流
           全双工                       全双工
    TCP
    TCP设计核心：
    1.可靠性：发送者能知道自己发送成功没成功
     2.传输效率：可靠性的前提下尽量提高传输效率
    
     一、确认应答 
          保证可靠性的核心机制
          为了区分当前是 应答哪个数据，需要引入序号和确认序号的概念；
                    序号是给每个字节都编了号
                    确认序号表示的是当前之前的数据都已经收到了，同时也意味着向    发送端索要当前确认序号开始的数据
    二、超时重传
         也是可靠传输中的最核心机制
         传输一条数据没有确认应答的时候，等待一段时间，然后进行重传，重传可能去重复若干次，重传的次数越多，丢包的概率越小，重传的等待时间间隔也在依次变长
    三、连接管理
         三次握手建立连接
         四次挥手断开连接
        建立连接的意义：
           1.双方各自试探双方看看双方是否合适跟我建立连接，双方的读写数据能力
           2.双方可以在建立连接过程中协商一些必要的数据（TCP序号的基准值）
    三次握手具体过程：
             客户端先发起一个连接请求（SNY同步报文段）
             服务器收到SNY之后会立刻返回一个确认报文段ACK，同时回复的这个ACK也是一个SNY
            客户端收到SNY之后再返回一个ACK
    涉及到的重要状态：
            1.LISTEN状态：表示可建立连接
            2.ESTABLISHED状态：表示连接成功可以通信
        四次挥手：
             CLOSE_WAIT：等待程序调用close来完成最终的断开连接
                   如果一个程序中有大量CLOSE_WAIT是因为代码里有bug，代码中的close忘了调或者没有执行到
            TIME_WAIT：虽然此时程序可能已经结束了，但是还是要保持连接为TIME_WAIT状态一段时间，因为发生的最后一个ACK可能会丢包
    四、滑动窗口
      窗口：不等待ACK的情况下批量发送多少数据
      滑动：每次收到一个ACK之后，就依次发送下一条数据，等待ACK的数据区间就在往后移动；
      窗口越大，传输速率就越高
      可靠性：如果窗口无限大，那么接收端可能处理不过来，网络环境也可能承载不了
     如果在滑动窗口过程中丢包怎么办？
            如果是ACK丢了，没事，确认序号表示的含义是当前序号之前的数据都收到了，后一个ACK就能涵盖前一个ACK的含义
           如果是数据包丢了，


    五、流量控制
      限制滑动窗口大小的一种机制
      根据接收端的处理能力来进行限制
      
      接收缓冲区：
                 
            

            
         
    